//package main
//
//import (
//	"fmt"
//)
//
//func ChangeMap(m map[int]int) {
//	m[1] = 2
//}
//
//func main() {
//	var a = make(map[int]int)
//	a[1] = 1
//	fmt.Println(a)
//	ChangeMap(a)
//	fmt.Println(a)
//}

//package main
//
//import (
//	"fmt"
//)
//
//func ChangeMap(m map[int]int) {
//	m = nil
//}
//
//func main() {
//	var a map[int]int = make(map[int]int)
//	a[1] = 1
//	fmt.Println(a)
//	ChangeMap(a)
//	fmt.Println(a)
//}

//package main
//
//import (
//"fmt"
//)
//
//func ChangeMap(m map[int]int) {
//	m = nil
//}
//
//func main() {
//	var a map[int]int
//
//	fmt.Println(a==nil)
//}

// panic recover go中把错误和异常区分开来，我们在写程序的时候可预知到的是错误，显示将它捕获并进行处理；不可预知的叫做异常。

//package main
//
//import (
//	"fmt"
//)
//
//func ChangeMap(m map[int]int) {
//	m = nil
//}
//
//func main() {
//	var a map[int]int
//
//	for _,value := range a {
//		fmt.Println(value)
//	}
//}

// 子协程中panic无法被外层recover捕获
package main

//// 空接口
//type Person struct {
//	Name string
//	Age int
//}
//
//
//func main() {
//	//a := 1
//	//b := &a //  &代表取出a变量的地址，a本身可以是一个普通变量也可以是一个指针变量
//	//c := *b // * 取地址对应的值
//	//println(a)
//	//fmt.Printf("%T\n",b)
//	//fmt.Printf("%T\n",c)
//	//println(c)
//	//res, _ := http.Get("http://1.117.229.170:9200/voc_yuwell")
//	//fmt.Println(res.StatusCode)
//
//
//	//a := []string{"a","c","b"}
//	//b := make([]string,0)
//	//for _,item := range a {
//	//	b = append(b,item)
//	//}
//	//fmt.Println(b)
//
//	var a map[string]interface{}
//
//	//a["1"] = Person{Name: "bobby",Age: 18}
//	a["2"] = 1
//	a["3"] = "1"
//	a["4"] = []string{"1"}
//	fmt.Println("从此时的a是  %s",a)
//
//	b := make([]interface{},0)
//	for index,val := range a {
//		fmt.Println("此时的index是 %v",index)
//		b = append(b,val)
//
//	}
//
//
//}

// 排序

//type Course struct {
//	Name string
//	Url string
//	Price int
//}
//
//type Courses []Course
//
//func (c Courses) Len() int {
//func (c Courses) Len() int {
//	return len(c)
//}
//
//func (c Courses) Less(i, j int) bool {
//	// 这里决定是正序还是逆序
//	return c[i].Price < c[j].Price
//}
//
//func (c Courses) Swap(i, j int)  {
//	c[i],c[j] = c[j],c[i]
//}
//
//func main()  {
//
//	course := Courses{
//		Course{Name: "django",Price: 10,Url: "11"},
//		Course{Name: "flask",Price: 9,Url: "11"},
//		Course{Name: "sanic",Price: 12,Url: "11"},
//	}
//
//	sort.Sort(course) // 这里的course 不一定是某种特定的类型，可以是切片，结构体，map 等等
//	for index,val := range course {
//		fmt.Println(index,val)
//	}
//	// 如何进行逆序排列
//
//}

// go 中 import 的 实际上是 包的路径。
// 注意变量对外暴露的时候需要首字母大写
// go中不同文件名但是为同一个package，相互之间也可以直接使用

// import 的几个注意事项：1、import的其实是包所在的路径和文件命名本身没有关系；同一个包下不能出现两个相同的package名称；import的
// 时候可以给模块加上别名 _ 不使用，. 直接使用package里面的函数名称不用再加前缀。

// init 函数会在该包被import的时候自动执行一次，但是同一个包下多个文件下定义多个init函数虽然都会被执行一遍但是无法保证顺序，因此
// 同一个package下不建议定义多个init函数。

// TODO 1
//func main()  {
//	for {
//		for i := 0;i < 5;i ++ {
//			go func(i int) {
//				fmt.Printf("当前运行到了第 %v\n 个",i)
//				json := `{
//        "start": "2022-01-22 00:00:00",
//        "end": "2022-01-29 00:00:00",
//        "timeword": "近7天",
//        "level1_label": "产品体验",
//        "goods_name": "",
//        "level3_label": {
//            "sentiment": "正面",
//            "value": "便捷性"
//        }
//    }`
//				payload := strings.NewReader(json)
//				res,err := http.Post("http://1.117.229.170:10001/user_feedback_level3_goods_list","application/json",payload)
//				if err != nil {
//					fmt.Printf("请求失败，当前的i是 %v",i)
//				}
//				fmt.Println("请求成功,当前响应的总条数是 %v",res.Body)
//
//			}(i)
//		}
//
//
//		fmt.Println("运行了main")
//		time.Sleep(time.Second*2)
//	}
//
//}

//func main() {
//var b interface{}
// 发送请求
//jsonBody := `{
//    "start": "2022-01-22 00:00:00",
//    "end": "2022-01-29 00:00:00",
//    "timeword": "近7天",
//    "level1_label": "产品体验",
//    "goods_name": "",
//    "level3_label": {
//        "sentiment": "正面",
//        "value": "便捷性"
//    }
//}`
//payload := strings.NewReader(jsonBody)
//res, err := http.Post("http://1.117.229.170:10001/user_feedback_level3_goods_list", "application/json", payload)
//
//// https://mholt.github.io/json-to-go/
//// 通过响应数据格式，根据上面的网站可直接获取结构体定义方便后续数据解析
//
//var u AutoGenerated
//data, err := ioutil.ReadAll(res.Body)
//if err != nil {
//	fmt.Printf("请求失败")
//	return
//}
//json.Unmarshal(data, &u)
//fmt.Println("响应状态码是", res.StatusCode, u.Data[0].DataID)
//for index,val := range u.Data {
//	fmt.Printf("响应数据 %v %v\n",index,val.GoodsName)
//}
//fmt.Println("响应成功了")
//value,ok := u.(map[string]interface{})
//if ok {
//	for key,val := range value {
//		if key == "data" {
//			newVal,ok := val.([]interface{})
//			if ok {
//				for innerKey, innerVal := range newVal {
//
//					fmt.Printf("每一个kv的值是 %v %v\n", innerKey, innerVal)
//				}
//			}
//		}
//	}
//	//fmt.Println(value)
//} else {
//	fmt.Println("类型断言失败")
//}
//fmt.Println("断言成功了")

//for index,val := range u.Data {
//	fmt.Printf("此时的index是: %v,val是: %v\n",index,val)
//}

// TODO 断言建议这么写
//switch i := x.(type) {
//case nil:
//	printString("x is nil") // i的类型是 x的类型 (interface{})
//case int:
//	printInt(i) // i的类型 int
//case float64:
//	printFloat64(i) // i的类型是 float64
//case func(int) float64:
//	printFunction(i) // i的类型是 func(int) float64
//case bool, string:
//	printString("type is bool or string") // i的类型是 x (interface{})
//default:
//	printString("don't know the type") // i的类型是 x的类型 (interface{})
//}

//fmt.Println("请求成功,当前响应的总条数是 %v",res.Body)
//}

var x []int

type X []int

func add(a, b int) X {
	x = append(x, a)
	return x
}

func main() {
	c := []int{1, 2}
}
